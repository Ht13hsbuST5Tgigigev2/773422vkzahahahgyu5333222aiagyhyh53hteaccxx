<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Durak — aqri.dev</title>
<meta name="description" content="Cozy P2P Durak (24/36 cards). Drag to play. Throw-ins always ON. No servers."/>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=PT+Serif:wght@400;700&family=Inter:wght@400;600;800&family=Russo+One&display=swap" rel="stylesheet">
<style>
  :root{ --bg:#160d06; --wood1:#3a2414; --wood2:#5a3620; --wood3:#7a4a2a; --ink:#1b110b; --paper:#f7f0e7; --paper2:#e7dac8; --smoke:#e8dccf; --muted:#cdb7a0; --accent:#d8a24a; --brand:#a73d3d; --shadow:rgba(0,0,0,.35); --red:#b12020; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--smoke);
    background:
      radial-gradient(1000px 600px at 0% 0%, rgba(215,160,90,.25), transparent 70%),
      radial-gradient(900px 600px at 100% 20%, rgba(167,61,61,.20), transparent 70%),
      repeating-linear-gradient( 90deg, var(--wood1) 0 18px, var(--wood2) 18px 36px, var(--wood3) 36px 54px), #160d06;
    font:16px/1.45 "Inter", system-ui, -apple-system, Segoe UI, Roboto, Arial;
  }
  .wrap{max-width:1200px;margin:0 auto;padding:20px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:14px}
  .brand{display:flex;align-items:center;gap:12px}
  .seal{width:44px;height:44px;border-radius:12px;background:radial-gradient(circle at 30% 30%, #f3d9a2, #b77f2c 65%, #5a361e 66%); outline:2px solid #301c10; box-shadow:0 3px 12px var(--shadow); display:grid;place-items:center}
  .seal span{font-family:"Russo One", system-ui; font-size:18px;color:#4c140e;text-shadow:0 1px 0 #f4e0b1}
  .title{font-family:"PT Serif", serif; font-weight:700; font-size:22px; letter-spacing:.3px;}
  .tab{appearance:none;border:0;cursor:pointer;padding:10px 14px;border-radius:12px;background:linear-gradient(180deg, #6a4026, #3f2616);color:var(--smoke);border:1px solid #2c1a0f;box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 2px 8px var(--shadow)}
  .tab.active{outline:2px solid var(--accent); box-shadow:0 0 0 3px rgba(216,162,74,.2), inset 0 1px 0 rgba(255,255,255,.1)}

  .panel{background:linear-gradient(180deg, #2d1b10, #1b120b); border:1px solid #2c1a0f; border-radius:16px; padding:16px; box-shadow:0 12px 30px var(--shadow)}
  .panel h2{font-family:"PT Serif", serif; font-size:16px; margin:0 0 10px 0; color:var(--smoke); letter-spacing:.03em}

  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  input, .btn, textarea, select{font:inherit;color:var(--smoke)}
  input[type="text"], textarea, select{padding:11px 12px;border-radius:12px;background:#25170f;border:1px solid #3c2719;outline:none;box-shadow:inset 0 1px 0 rgba(255,255,255,.05)}
  input[type="text"], select{height:42px}
  textarea{width:100%;min-height:120px;resize:vertical}
  .btn{appearance:none;border-radius:12px;border:1px solid #3c2719;background:linear-gradient(180deg, #704129, #4e2e1b);padding:10px 12px;font-weight:600;cursor:pointer;box-shadow:inset 0 1px 0 rgba(255,255,255,.08),0 2px 8px var(--shadow);color:#f0e7de}
  .btn:hover{filter:brightness(1.06)}
  .btn.gold{background:linear-gradient(180deg,#e0b35d,#b9872f); color:#3b1d0a; border-color:#7a521c}

  .views{display:none}
  .views.active{display:block}

  .table{
    background:
      radial-gradient(500px 200px at 30% 10%, rgba(216,162,74,.18), transparent 70%),
      conic-gradient(from 0deg, #2b4e30, #264a2b, #2d5a35, #2b4e30);
    border:3px solid #254629; border-radius:22px; padding:16px; min-height:320px; position:relative
  }
  .felt-edge{position:absolute;inset:-10px; border-radius:28px; background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0)); z-index:-1}
  .cards{display:flex;flex-wrap:wrap;gap:12px}

  .card{width:90px;height:124px;border-radius:12px;background:linear-gradient(180deg,var(--paper),var(--paper2));color:var(--ink);border:1px solid #d0c1ad;display:grid;grid-template-rows:auto 1fr auto;box-shadow:0 4px 8px var(--shadow); user-select:none}
  .card .rank{font-weight:800;padding:6px 8px}
  .card .suit{display:grid;place-items:center;font-size:28px}
  .card .corner{font-size:12px;opacity:.85;padding:6px 8px;text-align:right}
  .card.red .rank,.card.red .suit,.card.red .corner{color:var(--red)}
  .card.trump{outline:2px solid var(--brand); box-shadow:0 0 0 3px rgba(167,61,61,.25)}
  .card.dragging{opacity:.7; transform:scale(1.04)}
  .pair{position:relative;width:90px;height:124px}
  .pair .attack{position:absolute;left:0;top:0;z-index:1}
  .pair .defend{position:absolute;left:14px;top:-10px;transform:rotate(10deg);z-index:2}

  .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  .log{max-height:160px;overflow:auto;background:#24160e;border-radius:12px;border:1px solid #3c2719;padding:10px;color:#e6d8c9}

  .two{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media (max-width:900px){.two{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="brand">
      <div class="seal"><span>ДК</span></div>
      <div class="title">Durak <span style="opacity:.75">— aqri.dev</span></div>
    </div>
    <div class="row">
      <span class="small">Name:</span>
      <span id="nameChip" class="tab" style="pointer-events:none">(not set)</span>
      <button class="tab" data-nav="home">Home</button>
      <button class="tab" data-nav="connect">Connect</button>
      <button class="tab" data-nav="room" id="tabRoom" disabled>Room</button>
    </div>
  </header>

  <!-- HOME -->
  <section id="view-home" class="views active">
    <div class="panel" style="margin-bottom:12px">
      <h2>Choose your name</h2>
      <div class="row" style="margin-bottom:8px">
        <input id="playerName" type="text" placeholder="e.g., Sasha" style="max-width:320px">
        <button id="btnSaveName" class="btn gold">Save</button>
      </div>
      <div class="small">Saved locally. No accounts, no servers.</div>
    </div>
    <div class="panel">
      <h2>How to connect</h2>
      <div class="small">
        Uses <b>WebRTC</b> with a manual copy–paste handshake (no backend). Host makes an Offer; Joiner makes an Answer; paste both; start.
      </div>
    </div>
  </section>

  <!-- CONNECT + LOBBY -->
  <section id="view-connect" class="views">
    <div class="panel" style="margin-bottom:12px">
      <h2>Lobby (Host only)</h2>
      <div class="row" style="margin-bottom:8px">
        <label>Deck size
          <select id="deckSize">
            <option value="36">36 (6..A)</option>
            <option value="24">24 (9..A)</option>
          </select>
        </label>
        <span class="small">Throw-ins are <b>always ON</b>.</span>
      </div>
    </div>

    <div class="two">
      <div class="panel">
        <h2>Host a table</h2>
        <div class="small" style="margin-bottom:6px">Create Offer → share → paste Answer → accept.</div>
        <div class="row" style="margin-bottom:8px">
          <button id="btnHost" class="btn gold">Create Offer</button>
        </div>
        <textarea id="offerOut" placeholder="Offer appears here" readonly></textarea>
        <div class="row" style="margin:8px 0">
          <button id="btnCopyOffer" class="btn">Copy Offer</button>
        </div>
        <textarea id="answerIn" placeholder="Paste Answer here"></textarea>
        <div class="row" style="margin-top:8px">
          <button id="btnAcceptAnswer" class="btn">Accept Answer</button>
        </div>
        <div class="small" id="hostStatus" style="margin-top:8px">Status: idle</div>
      </div>
      <div class="panel">
        <h2>Join a table</h2>
        <div class="small" style="margin-bottom:6px">Paste Offer → Create Answer → send back.</div>
        <textarea id="offerIn" placeholder="Paste Offer here"></textarea>
        <div class="row" style="margin:8px 0">
          <button id="btnMakeAnswer" class="btn gold">Create Answer</button>
        </div>
        <textarea id="answerOut" placeholder="Your Answer appears here" readonly></textarea>
        <div class="row" style="margin-top:8px">
          <button id="btnCopyAnswer" class="btn">Copy Answer</button>
        </div>
        <div class="small" id="joinStatus" style="margin-top:8px">Status: idle</div>
      </div>
    </div>
  </section>

  <!-- ROOM -->
  <section id="view-room" class="views">
    <div class="panel" style="margin-bottom:12px">
      <div class="row" style="justify-content:space-between;width:100%">
        <div class="row" style="gap:8px">
          <span class="tab" style="pointer-events:none">You: <b id="youRole">—</b></span>
          <span class="tab" style="pointer-events:none">Opponent: <b id="oppName">—</b></span>
          <span class="tab" style="pointer-events:none">Trump: <b id="trumpSuit">—</b></span>
          <span class="tab" style="pointer-events:none">Stock: <b id="stockCount">0</b></span>
          <span class="tab" style="pointer-events:none">Discard: <b id="discardCount">0</b></span>
          <span class="tab" style="pointer-events:none">Opponent cards: <b id="oppCount">0</b></span>
          <span class="tab" style="pointer-events:none">Timer: <b id="turnTimer">—</b></span>
        </div>
        <div class="row">
          <button class="btn" id="btnLeaveRoom">Leave</button>
        </div>
      </div>
    </div>

    <div class="table" id="tableDrop">
      <div class="felt-edge"></div>
      <div class="row" style="margin-bottom:8px"><span class="small">Drag to the felt to attack, or onto a pending attack to defend that one. Throw-ins always ON.</span></div>
      <div id="pairs" class="cards" style="margin-bottom:10px"></div>
      <div class="row" style="margin-bottom:8px"><span class="small">Pending attacks (drop defence directly on one):</span></div>
      <div id="attacks" class="cards"></div>
      <div id="turnHint" class="small" style="position:absolute;right:12px;bottom:12px">—</div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="hud">
        <button class="btn" id="btnStartGame" disabled>Start game (Host)</button>
        <button class="btn" id="btnTake" disabled>Take</button>
        <button class="btn" id="btnEnd" disabled>End attack</button>
        <button class="btn" id="btnSurrender" disabled>Surrender</button>
        <button class="btn" id="btnRestart">Restart</button>
        <span id="info" class="small">Max 6 attacks per bout (limit set at bout start). With defences that’s up to 12 cards on the table.</span>
      </div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="row" style="margin-bottom:6px"><span class="small">Your hand (drag a card)</span></div>
      <div id="yourHand" class="cards"></div>
    </div>

    <div class="panel" style="margin-top:12px">
      <div class="row" style="margin-bottom:6px"><span class="small">Game log</span></div>
      <div id="log" class="log"></div>
    </div>
  </section>
</div>

<div id="toast" style="display:none; position:fixed; right:16px; bottom:16px; z-index:9999; min-width:240px; max-width:420px; padding:12px 14px; border-radius:12px; border:1px solid #6a2323; background:linear-gradient(180deg,#5a2c2c,#3b1a1a); color:#f9eaea; box-shadow:0 10px 24px rgba(0,0,0,.35)"></div>

<script>
/* ===== Helpers ===== */
const $ = s => document.querySelector(s);
const $$ = s => Array.from(document.querySelectorAll(s));
const toast = (msg,ms=3000)=>{const t=$("#toast"); if(!t){alert(msg);return;} t.textContent=(typeof msg==='string')?msg:(msg?.message||String(msg)); t.style.display='block'; clearTimeout(t._timer); t._timer=setTimeout(()=>t.style.display='none',ms);};
const log = (txt)=>{const d=document.createElement('div'); d.textContent=txt; $('#log').prepend(d);};
const views={home:$('#view-home'),connect:$('#view-connect'),room:$('#view-room')};
function nav(to){ Object.values(views).forEach(v=>v.classList.remove('active')); views[to].classList.add('active'); $$('.tab').forEach(t=>t.classList.toggle('active',t.dataset.nav===to)); }
$$('.tab').forEach(b=>b.addEventListener('click',()=>{const v=b.dataset.nav;if(v==='room'&&!state.connected)return;nav(v)}));

/* ===== Global state ===== */
const TURN_LIMIT_SEC=60;
const state={
  name:localStorage.getItem('durakName')||'',
  connected:false,isHost:false,uid:null,peerName:'—',
  pc:null,dc:null,
  room:null,
  settings:{deckSize:36}
};
$('#playerName').value=state.name; $('#nameChip').textContent=state.name||'(not set)';
$('#btnSaveName').onclick=()=>{const v=$('#playerName').value.trim(); if(!v){toast('Enter a name');return;} state.name=v; localStorage.setItem('durakName',v); $('#nameChip').textContent=v; toast('Saved');};

/* ===== WebRTC (manual copy/paste) ===== */
const iceServers=[{urls:'stun:stun.l.google.com:19302'}];
const enc=x=>btoa(unescape(encodeURIComponent(JSON.stringify(x))));
const dec=s=>JSON.parse(decodeURIComponent(escape(atob(s.trim()))));
function createPeer(){const pc=new RTCPeerConnection({iceServers}); state.pc=pc;
  pc.onicecandidate=()=>{if(pc.localDescription){const blob=enc(pc.localDescription); if(state.isHost) $('#offerOut').value=blob; else $('#answerOut').value=blob;}};
  pc.onconnectionstatechange=()=>{['#hostStatus','#joinStatus'].forEach(id=>{const el=$(id); if(el) el.textContent='Status: '+pc.connectionState;}); if(pc.connectionState==='connected') onConnected();};
  return pc;
}
function bindDC(dc){ state.dc=dc; dc.onopen=()=>{state.connected=true; $('#tabRoom').disabled=false; nav('room'); send({t:'hello',name:state.name});}; dc.onmessage=e=>onMsg(JSON.parse(e.data)); dc.onclose=()=>{state.connected=false; toast('Disconnected');};}
function send(o){ try{ state.dc?.send(JSON.stringify(o)); }catch{} }

/* Host */
$('#btnHost').onclick=async()=>{
  if(!state.name) return nav('home'),toast('Set your name first');
  state.settings.deckSize=parseInt($('#deckSize').value,10);
  state.isHost=true; state.uid='A';
  const pc=createPeer(); bindDC(pc.createDataChannel('durak',{ordered:true}));
  await pc.setLocalDescription(await pc.createOffer());
  $('#btnStartGame').disabled=false;
};
$('#btnAcceptAnswer').onclick=async()=>{try{await state.pc.setRemoteDescription(dec($('#answerIn').value)); toast('Answer accepted');}catch{toast('Invalid answer');}};

/* Guest */
$('#btnMakeAnswer').onclick=async()=>{
  if(!state.name) return nav('home'),toast('Set your name first');
  state.isHost=false; state.uid='B';
  const pc=createPeer(); pc.ondatachannel=e=>bindDC(e.channel);
  try{
    const offer=dec($('#offerIn').value);
    await pc.setRemoteDescription(offer);
    const ans=await pc.createAnswer(); await pc.setLocalDescription(ans);
  }catch{toast('Invalid offer');}
};
$('#btnCopyOffer').onclick=()=>{const t=$('#offerOut').value; if(t) navigator.clipboard?.writeText(t);};
$('#btnCopyAnswer').onclick=()=>{const t=$('#answerOut').value; if(t) navigator.clipboard?.writeText(t);};

function onConnected(){ $('#info').textContent=state.isHost?'You are host. Click Start.':'Connected. Waiting for host.'; }
function onMsg(m){
  if(m.t==='hello'){state.peerName=m.name||'Opponent'; $('#oppName').textContent=state.peerName; if(!state.isHost) send({t:'hello',name:state.name});}
  else if(m.t==='init'){state.room=m.room; render();}
  else if(m.t==='state'){state.room=m.room; render();}
  else if(m.t==='move' && state.isHost){handleMoveFromGuest(m);}
  else if(m.t==='surrender' && state.isHost){opSurrender('B');}
  else if(m.t==='restart' && state.isHost){hostStartGame(true);}
}

/* ===== Durak logic (throw-ins ON) ===== */
const SUITS=()=>['♠','♥','♦','♣'];
const ranks = ()=> state.room?.ranks || (state.settings.deckSize===24? ['9','10','J','Q','K','A'] : ['6','7','8','9','10','J','Q','K','A']);
const rIdx = r => ranks().indexOf(r);
let CARD_ID=0;
const freshDeck=()=>{const d=[]; for(const s of SUITS()) for(const r of ranks()) d.push({id:CARD_ID++, s, r}); for(let i=d.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [d[i],d[j]]=[d[j],d[i]];} return d;};
const canBeat=(a,d,tr)=> (a && d) && (a.s===d.s? rIdx(d.r)>rIdx(a.r) : d.s===tr && a.s!==tr);
const sortHand=(a,b)=>{const t=state.room?.trump,so={'♠':0,'♥':1,'♦':2,'♣':3}; const sa=(a.s===t?4:so[a.s]), sb=(b.s===t?4:so[b.s]); return sa!==sb? sa-sb : rIdx(a.r)-rIdx(b.r);};

function ranksOnTable(r){ const set=new Set(); (r.table||[]).forEach(p=>{ if(p.attack) set.add(p.attack.r); if(p.defend) set.add(p.defend.r);}); (r.attacks||[]).forEach(a=>set.add(a.r)); return set; }
function totalAttacks(r){ return (r.table?.length||0)+(r.attacks?.length||0); } // count of attack cards
function startBout(r){ r.boutLimit = Math.min(6, r.hands[r.defenderUid].length); }
function canAddAttack(r,card){
  const t=totalAttacks(r);
  if(t >= r.boutLimit) return false;              // fixed per bout
  if(t === 0) return true;                        // first attack any rank
  return ranksOnTable(r).has(card.r);             // add only ranks on table
}

/* guards for card ownership (prevents double-use) */
function findCardIndex(r, uid, cid){ return r.hands[uid].findIndex(c=>c.id===cid); }
function removeCardFromHand(r, uid, cid){
  const i=findCardIndex(r,uid,cid);
  if(i<0) return null;
  return r.hands[uid].splice(i,1)[0];
}

/* Phases & enforcement */
function setPhase(r, phase){
  r.phase = phase;
  if(phase==='attack' || phase==='add') r.turnUid = r.attackerUid;
  else if(phase==='defend') r.turnUid = r.defenderUid;
  else if(phase==='done') r.turnUid = null;
}
function boutCovered(r){ return r.attacks.length===0 && r.table.length>0 && r.table.every(p=>!!p.defend); }
function enforceState(r){
  if(r.attacks.length>0){ setPhase(r,'defend'); }
  else if(boutCovered(r)){ setPhase(r,'add'); }
  else { setPhase(r,'attack'); }
}

/* Game bootstrap */
function hostStartGame(restart=false){
  if(!state.isHost||!state.connected) return toast('Only host can start after connecting');
  const deck=freshDeck(); const trumpCard=deck[deck.length-1]; const trump=trumpCard.s;
  const hands={A:[],B:[]}; for(let i=0;i<6;i++){hands.A.push(deck.pop()); hands.B.push(deck.pop());}
  function firstAttacker(){const lt=u=>{const t=hands[u].filter(c=>c.s===trump).map(c=>rIdx(c.r)).sort((a,b)=>a-b); return t.length?t[0]:99}; const a=lt('A'),b=lt('B'); if(a<b) return 'A'; if(b<a) return 'B'; return 'A';}
  const attacker=firstAttacker(), defender= attacker==='A'?'B':'A';
  state.room={status:'playing',deck,trump,trumpCard,ranks:ranks(),
    hands,stockCount:deck.length,discardCount:0,
    attackerUid:attacker,defenderUid:defender,turnUid:attacker,
    phase:'attack', table:[], attacks:[], boutLimit:6,
    names:{A:state.name,B:state.peerName||'Opponent'},
    turnDeadline:Date.now()+TURN_LIMIT_SEC*1000 };
  startBout(state.room); setPhase(state.room,'attack');
  send({t:'init',room:state.room}); render();
  log(restart?'— Restarted':'— New game');
}
$('#btnStartGame').onclick=()=> state.isHost && hostStartGame();

/* Host authoritative ops */
function resetDeadline(){ if(state.isHost&&state.room) state.room.turnDeadline=Date.now()+TURN_LIMIT_SEC*1000; }
function broadcast(){ const r=state.room; enforceState(r); send({t:'state',room:r}); render(); }

function opAttack(uid,card){
  const r=state.room; if(!r) return;
  const attackerActing = (uid===r.attackerUid) && (r.phase==='attack' || r.phase==='defend' || r.phase==='add');
  if(!attackerActing) return;

  // must own exact card id
  const mine = removeCardFromHand(r, uid, card.id);
  if(!mine) return;

  if(!canAddAttack(r,mine)) { // return card if illegal
    r.hands[uid].push(mine); r.hands[uid].sort(sortHand); return;
  }
  r.attacks.push(mine);
  setPhase(r,'defend'); resetDeadline(); broadcast();
}

function defendAtIndex(uid, card, i){
  const r=state.room; if(!r || uid!==r.defenderUid) return;
  if(r.attacks.length===0) return;

  // must own exact card id
  const mine = removeCardFromHand(r, uid, card.id);
  if(!mine) return;

  // pick target index
  if(i==null){ i = r.attacks.findIndex(a=>canBeat(a,mine,r.trump)); }
  const a=r.attacks[i];
  if(i<0 || !a || !canBeat(a,mine,r.trump)){
    // put back if cannot defend
    r.hands[uid].push(mine); r.hands[uid].sort(sortHand); return;
  }
  r.table.push({attack:a,defend:mine});
  r.attacks.splice(i,1);

  enforceState(r); resetDeadline(); broadcast();
}

function endBoutToDiscard(){
  const r=state.room;
  const pile=r.table.flatMap(p=>[p.attack,p.defend]).filter(Boolean);
  r.discardCount+=pile.length; r.table=[]; r.attacks=[];
  // refill: attacker first, then defender
  for(const uid of [r.attackerUid,r.defenderUid]){
    while(r.hands[uid].length<6 && r.deck.length>0){ r.hands[uid].push(r.deck.pop()); r.stockCount=r.deck.length; }
  }
  // swap roles and start next bout
  [r.attackerUid,r.defenderUid]=[r.defenderUid,r.attackerUid];
  startBout(r); setPhase(r,'attack'); checkGameEnd(r);
}

function opEnd(uid){
  const r=state.room; if(!r || uid!==r.attackerUid) return;
  if(!boutCovered(r)) return;
  endBoutToDiscard(); resetDeadline(); broadcast();
}

function opTake(uid){
  const r=state.room; if(!r || uid!==r.defenderUid) return;
  if(r.attacks.length===0 && r.table.length===0) return;
  const pile=r.attacks.concat(r.table.flatMap(p=>[p.attack,p.defend])).filter(Boolean);
  r.hands[r.defenderUid]=r.hands[r.defenderUid].concat(pile);
  r.attacks=[]; r.table=[];
  // refill: attacker first, then defender
  for(const u of [r.attackerUid,r.defenderUid]){
    while(r.hands[u].length<6 && r.deck.length>0){ r.hands[u].push(r.deck.pop()); r.stockCount=r.deck.length; }
  }
  // attacker keeps turn; new bout & limit
  startBout(r); setPhase(r,'attack'); checkGameEnd(r);
  resetDeadline(); broadcast();
}

function opSurrender(uid){
  const r=state.room; if(!r||r.status!=='playing') return;
  r.status='finished'; r.loserUid=uid; r.winnerUid= uid==='A'?'B':'A'; setPhase(r,'done');
  log(`${r.names[uid]} surrendered`);
  broadcast();
}
function opTimeout(uid){ opSurrender(uid); }

function checkGameEnd(r){
  const empty=r.deck.length===0, a=r.hands[r.attackerUid].length, d=r.hands[r.defenderUid].length;
  if(empty && (a===0 || d===0)){
    r.status='finished';
    if(a===0 && d>0){ r.winnerUid=r.attackerUid; r.loserUid=r.defenderUid; }
    else if(d===0 && a>0){ r.winnerUid=r.defenderUid; r.loserUid=r.attackerUid; }
    else { r.winnerUid=r.attackerUid; r.loserUid=r.defenderUid; }
    setPhase(r,'done'); log(`Game over • ${r.names[r.winnerUid]} wins`);
  }
}

/* Guest → Host relay */
function handleMoveFromGuest(m){ const uid='B';
  if(m.op==='attack') opAttack(uid,m.card);
  else if(m.op==='defend') defendAtIndex(uid,m.card,m.i);
  else if(m.op==='take') opTake(uid);
  else if(m.op==='end') opEnd(uid);
}

/* Timer watchdog (host) */
setInterval(()=>{ const r=state.room; if(state.isHost && r && r.status==='playing' && Date.now()>r.turnDeadline){ opTimeout(r.turnUid); } }, 1000);

/* ===== Drag & Drop ===== */
function dragStart(ev,c){
  try{ ev.dataTransfer.setData('application/json', JSON.stringify(c)); }catch{}
  try{ ev.dataTransfer.setData('text/plain', JSON.stringify(c)); }catch{}
  ev.dataTransfer.effectAllowed='move';
  ev.currentTarget.classList.add('dragging');
}
function dragEnd(ev){ ev.currentTarget.classList.remove('dragging'); }

const drop=$('#tableDrop');
drop.addEventListener('dragover',ev=>{ ev.preventDefault(); ev.dataTransfer.dropEffect='move'; });
drop.addEventListener('drop',ev=>{
  ev.preventDefault();
  // If dropped on a specific attack target, ignore container (prevents double handling)
  if(ev.target.closest('.attack-target')) return;

  const json = ev.dataTransfer.getData('application/json') || ev.dataTransfer.getData('text/plain');
  if(!json) return;
  const c=JSON.parse(json); const r=state.room; if(!r) return;
  const amAtt=state.uid===r.attackerUid, amDef=state.uid===r.defenderUid;

  if(amDef && r.attacks.length>0){
    if(state.isHost) defendAtIndex(state.uid,c,null);
    else send({t:'move',op:'defend',card:c});
    return;
  }
  if(amAtt && (r.phase==='attack' || r.phase==='defend' || r.phase==='add')){
    if(state.isHost) opAttack(state.uid,c); else send({t:'move',op:'attack',card:c});
  }
});

/* ===== Rendering ===== */
function makeCardEl(c,context='hand'){
  const el=document.createElement('div');
  el.className='card'; if(c.s==='♥' || c.s==='♦') el.classList.add('red');
  if(state.room && state.room.trump===c.s) el.classList.add('trump');
  el.innerHTML=`<div class="rank">${c.r}</div><div class="suit">${c.s}</div><div class="corner">${c.r}${c.s}</div>`;
  if(context==='hand'){ el.draggable=true; el.addEventListener('dragstart',e=>dragStart(e,c)); el.addEventListener('dragend',dragEnd); }
  return el;
}
function render(){
  const r=state.room; if(!r) return;
  const other=state.uid==='A'?'B':'A';
  $('#trumpSuit').textContent=r.trump; $('#stockCount').textContent=r.stockCount??0; $('#discardCount').textContent=r.discardCount??0;
  $('#oppName').textContent=r.names[other]; $('#oppCount').textContent=r.hands[other].length;
  $('#youRole').textContent=state.uid===r.attackerUid?'Attacker':'Defender';

  const myTurn = state.uid===r.turnUid;
  let phaseWord = r.phase==='add' ? 'add' : r.phase;
  let hint = myTurn ? `Your move • ${phaseWord}` : `Opponent’s move • ${phaseWord}`;
  if(!myTurn && r.phase==='defend' && state.uid===r.attackerUid) hint = 'Opponent defends • you may still add';
  $('#turnHint').textContent = hint;

  $('#btnStartGame').disabled=!(state.isHost && state.connected && r.status!=='playing');
  $('#btnTake').disabled=!(r.attacks.length>0 && state.uid===r.defenderUid);
  const canEnd = (state.uid===r.attackerUid) && (r.attacks.length===0) && r.table.length>0 && r.table.every(p=>p.defend) && (r.status==='playing');
  $('#btnEnd').disabled=!canEnd;
  $('#btnSurrender').disabled=!(r.status==='playing');

  if(r.turnDeadline){ const s=Math.max(0,Math.ceil((r.turnDeadline-Date.now())/1000)); $('#turnTimer').textContent = s+'s'; }

  const hand=$('#yourHand'); hand.innerHTML='';
  r.hands[state.uid].slice().sort(sortHand).forEach(c=>hand.appendChild(makeCardEl(c,'hand')));

  const pairs=$('#pairs'); pairs.innerHTML='';
  r.table.forEach(p=>{ const wrap=document.createElement('div'); wrap.className='pair';
    const a=makeCardEl(p.attack,'table'); a.classList.add('attack'); wrap.appendChild(a);
    if(p.defend){ const d=makeCardEl(p.defend,'table'); d.classList.add('defend'); wrap.appendChild(d); }
    pairs.appendChild(wrap);
  });

  const attacks=$('#attacks'); attacks.innerHTML='';
  r.attacks.forEach((a,i)=>{
    const el=makeCardEl(a,'attack');
    el.classList.add('attack-target');
    el.dataset.idx=i;
    // Defender can drop exactly on this card to cover that index (stop bubbling!)
    el.addEventListener('dragover',ev=>{
      if(state.uid===r.defenderUid){ ev.preventDefault(); ev.stopPropagation(); ev.dataTransfer.dropEffect='move'; }
    });
    el.addEventListener('drop',ev=>{
      if(state.uid!==r.defenderUid) return;
      ev.preventDefault(); ev.stopPropagation();
      const json = ev.dataTransfer.getData('application/json') || ev.dataTransfer.getData('text/plain');
      if(!json) return;
      const c=JSON.parse(json);
      if(state.isHost) defendAtIndex(state.uid,c,i);
      else send({t:'move',op:'defend',card:c,i});
    });
    attacks.appendChild(el);
  });
}

/* ===== UI buttons ===== */
$('#btnTake').onclick=()=>{ if(state.isHost) opTake(state.uid); else send({t:'move',op:'take'}); };
$('#btnEnd').onclick=()=>{ if(state.isHost) opEnd(state.uid); else send({t:'move',op:'end'}); };
$('#btnSurrender').onclick=()=>{ if(state.isHost) opSurrender(state.uid); else send({t:'surrender'}); };
$('#btnLeaveRoom').onclick=()=>{ try{state.dc?.close();state.pc?.close();}catch{} state.connected=false; state.room=null; state.dc=null; state.pc=null; state.uid=null; nav('connect'); };
$('#btnRestart').onclick=()=>{ if(state.isHost) hostStartGame(true); else send({t:'restart'}); };

/* Lobby binding */
function updateLobby(){ state.settings.deckSize=parseInt($('#deckSize').value,10); }
$('#deckSize').onchange=updateLobby; updateLobby();

/* Init */
nav('home');
setInterval(()=>{ const r=state.room; if(!r) return; if(views.room.classList.contains('active')) render(); }, 300);
</script>

<!-- Notes:
  • Fix: A single defence card could apply to multiple attacks due to event bubbling; now each drop is handled exactly once and the host verifies card ownership by unique ID.
  • Throw-ins ALWAYS ON. Bout limit = min(6, defender hand at bout start). Up to 6 attacks + 6 defences.
  • Hearts/♦ and Diamonds/♥ render red like real decks.
  • Defend a specific pending attack by dropping onto it; dropping on felt auto-defends the first beatable.
-->
</body>
</html>

